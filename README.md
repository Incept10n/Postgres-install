# PostgresInstall App
## Prerequisites
Для корректной работы приложения нужны следующие установленные компоненты:
- Ansible
- Python3

Также очень важно убедиться, что есть удалённый доступ под root к удалённым машинам, т.е. например ```ssh root@158.160.182.75``` успешно работал и подключался.

Приложение тестировалось и работает удачно для последних версий ОС CentOs и Debian.

Само приложение разработано для Linux и использует bash в своей реализации.

## How to run the app
Чтобы запустить приложение достаточно склонировать репозиторий и под пользователем, у которого есть закрытая часть ключа root, ввести следующую команду из корневой директории проекта:

```python3 postgres-install.py x.x.x.x,y.y.y.y```

Где ```x.x.x.x``` и ```y.y.y.y``` - ip адреса удалённых серверов.

Пример команды:

```python3 postgres-install.py 158.160.182.75,158.160.150.234```

## Questions and Solutions

В этой главе опишу основные моменты реализации и проблемы, с которыми я сталкивался.

Первая задача, которая стояла - это понять какой сервер менее загружен. Сразу пришло в голову использовать Ansible facts для этого, но в этих данных не было общего понятия, что подразумевается под "нагруженностью". После некоторых раздумий я вспомнил про такую вещь как composite score (что-то такое было в университете, когда изучал ML), в итоге "нагруженность" формируется из трёх статистик и считается как:

```        overall_score: "{{ (cpu_ratio | float) * 0.5 + (mem_usage | float) * 0.3 + (disk_usage | float) * 0.2 }}" ```

То есть просто назначаются веса к определённым характеристикам, которые достаются из Ansible facts, а потом складываются.

После этого данные сохраняются, и выбирается лучший сервер.

Первая проблема, с которой я столкнулся, это неправильное заполнение файла load_report, куда и сохранялись данные о нагрузке. Суть в том, что Ansible делает операции параллельно, чего нам не надо, т.к. происходит перезапись значений (не всегда, но иногда), и я добавил строчку   ```serial: 1```, которая и позволила решить проблему.

Далее надо было установить Postgres, создать пользователя и базу данных, что делалось несложно и без проблем. 

Проблемы снова начались, когда работал с правами доступа через pg_hba. Причём с Debian всё быстро решилось, но с CentOs были проблемы с подключением. Оказалось, что на этом сервере был включен SELinux. После того как я включил его в permissive mode всё заработало.

Стоит отметить, что сначала я работал чисто с bare metal и может это фишка чисто с тем CentOs, который я устанавливал, но я всё равно добавил включение permissive mode в реализацию.

Также потом это приложение я протестировал на виртуальных машинах Yandex Cloud и всё работало также успешно.

Приложение полностью показывает статус инсталяции и также отправляет запрос ```SELECT 1;``` для проверки работоспособности БД.
